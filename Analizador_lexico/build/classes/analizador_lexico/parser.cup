package analizador_lexico;

import java_cup.runtime.*;
import java.util.*;

parser code {:
    scanner s;
    Parser(scanner s){ this.s=s; }
:}

init with {: scanner.init();              :};
scan with {: return scanner.next_token(); :};



terminal            int, double, bool, string, void, class, EXTENDS, implements, interface, if, 
                    else, while, for, return, break, Print, this, New, NewArray, ReadInteger, ReadLine, Malloc, intConstant, 
                    doubleConstant, boolConstant, stringConstant, null, GetByte, SetByte;

terminal            Semicolon, LeftParenthesis, RightParenthesis, LeftBracket, RightBracket, Comma,
                    Arithmetic_Op, Equal, Negation, Comparison_op, LeftBrace, RightBrace, Point;

terminal String     ident;

non terminal        Program, Decl, VariableDecl, Variable, Type, FunctionDecl, Formals, ClassDecl, Field, 
                    InterfaceDecl, Prototype, StmtBlock, Stmt, IfStmt, WhileStmt, ForStmt, ReturnStmt, 
                    BreakStmt, PrintStmt, Expr, LValue, Call, LibCall, Actuals, Constant;

non terminal        ProgramA, FormalsA, ClassDeclC, ClassDeclBb, ClassDeclB, ClassDeclA, InterfaceDeclA, IfStmtA,
                    PrintStmtA, PrintStmtAa, ForStmtA, ActualsA, StmtBlockA, StmtBlockB;


   
precedence left     int, double, bool, string, void, class, EXTENDS, implements, interface, if, 
                    else, while, for, return, break, Print, this, New, NewArray, ReadInteger, ReadLine, Malloc, intConstant, 
                    doubleConstant, boolConstant, stringConstant, null, GetByte, SetByte;

precedence left     Semicolon, LeftParenthesis, RightParenthesis, LeftBracket, RightBracket, Comma,
                    Arithmetic_Op, Equal, Negation, Comparison_op, LeftBrace, RightBrace, Point, ident;

                    
Program             ::= Decl ProgramA;
ProgramA            ::= Decl ProgramA
                      |;

Decl                ::= VariableDecl
                      | FunctionDecl
                      | ClassDecl
                      | InterfaceDecl;
VariableDecl        ::= Variable Semicolon;
Variable            ::= Type ident;
Type                ::= int
                      | double
                      | bool
                      | string
                      | ident
                      | Type LeftBracket RightBracket;
FunctionDecl        ::= Type ident LeftParenthesis Formals RightParenthesis StmtBlock
                      | void ident LeftParenthesis Formals RightParenthesis StmtBlock;

Formals             ::= Variable FormalsA
                      |;
FormalsA            ::= Comma Variable FormalsA
                      |;

ClassDecl           ::= class ident ClassDeclA ClassDeclB LeftBracket ClassDeclC RightBracket;
ClassDeclA          ::= EXTENDS ident |;
ClassDeclB          ::= implements ident ClassDeclBb |;
ClassDeclBb         ::= Comma ident ClassDeclBb |;
ClassDeclC          ::= Field ClassDeclC |;

Field               ::= VariableDecl 
                      | FunctionDecl;

InterfaceDecl       ::= interface ident LeftBracket InterfaceDeclA RightBracket;
InterfaceDeclA      ::= Prototype InterfaceDeclA |;

Prototype           ::= Type ident LeftParenthesis Formals RightParenthesis Semicolon
                      | void ident LeftParenthesis Formals RightParenthesis Semicolon;

StmtBlock           ::= LeftBracket StmtBlockA StmtBlockB RightBracket;
StmtBlockA          ::= StmtBlockA VariableDecl |;
StmtBlockB          ::= StmtBlockB Stmt |;

Stmt                ::= Expr Semicolon
                      | Semicolon
                      | IfStmt
                      | WhileStmt
                      | ForStmt
                      | BreakStmt
                      | ReturnStmt
                      | PrintStmt
                      | StmtBlock
                      |;
IfStmt              ::= if LeftParenthesis Expr RightParenthesis Stmt IfStmtA;
IfStmtA             ::= else Stmt |;

WhileStmt           ::= while LeftParenthesis Expr RightParenthesis Stmt;

ForStmt             ::= for LeftParenthesis ForStmtA Semicolon Expr Semicolon ForStmtA RightParenthesis;
ForStmtA            ::= Expr |;
ReturnStmt          ::= return ForStmtA Semicolon;

BreakStmt           ::= break Semicolon;

PrintStmt           ::= Print LeftParenthesis PrintStmtA RightParenthesis Semicolon;
PrintStmtA          ::= Expr PrintStmtAa;
PrintStmtAa         ::= Comma Expr PrintStmtAa |;

Expr                ::= LValue Equal Expr 
                      | Constant
                      | LValue
                      | this
                      | Call
                      | LeftParenthesis Expr RightParenthesis
                      | Expr Arithmetic_Op Expr
                      | Expr Comparison_op Expr
                      | Negation Expr
                      | New LeftParenthesis ident RightParenthesis
                      | NewArray LeftParenthesis Expr Comma Type RightParenthesis
                      | ReadInteger LeftParenthesis RightParenthesis
                      | ReadLine LeftParenthesis RightParenthesis
                      | Malloc LeftParenthesis Expr RightParenthesis;

LValue              ::= ident
                      | Expr Point ident    
                      | Expr LeftBrace Expr RightBrace;

Call                ::= ident LeftParenthesis Actuals RightParenthesis
                      | Expr Point ident LeftParenthesis Actuals RightParenthesis
                      | Expr Point LibCall LeftParenthesis Actuals RightParenthesis;

LibCall             ::= GetByte LeftParenthesis Expr RightParenthesis
                      | SetByte LeftParenthesis Expr Comma Expr RightParenthesis;

Actuals             ::= Expr ActualsA
                      |;
ActualsA            ::= Comma ActualsA |;

Constant            ::= intConstant
                      | doubleConstant
                      | boolConstant
                      | stringConstant
                      | null;