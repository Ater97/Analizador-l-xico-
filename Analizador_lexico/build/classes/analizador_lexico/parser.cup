package analizador_lexico;
import java.util.ArrayList;
import java_cup.runtime.*;

parser code  {: 

   public String ErrorM = "";
   public int ErrorNumber = 0;

    public void ReadToken (Symbol cur_token)
    {
        System.out.println("ReadToken " + cur_token.value);
    }

   public void syntax_error(Symbol cur_token) {  
        ErrorNumber++;
        ErrorM += ErrorNumber + " Sintac Message Line: " + (cur_token.left+1) + " Col: " +(cur_token.right+1) + " Text: " + cur_token.value+"\n";
    //    report_error("Error de sintaxis. Columna: " + (cur_token.right + 1) + " Linea: " + (cur_token.left+1) + ". Texto: \"" + cur_token.value + "\"", null);
   }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception 
    {
    }
       
:};
action code {:
            public String type (Object obj)
            {
                Integer temp;
                if (obj instanceof Integer)
                    return "int";
                else if (obj instanceof Double)
                    return "doub";
                else if (obj instanceof String)
                    return "str";
                else if (obj instanceof Boolean)
                    return "doub";
                else 
                    return "n";
                //temp = Integer.parseInt(String.valueOf(obj));
                //System.out.println(" \\ 0.0/ " + obj);
            }


        :}
//--------------------------------------------------------------------------------
terminal Object     INT, DOUBLE, BOOL, STRING, VOID, CLASS, EXTENDS, IMPLEMENTS, INTERFACE, IF,
                    ELSE, WHILE, FOR, RETURN, BREAK, PRINT, THIS, NEW, NEWARRAY, READINTEGER,
                    READLINE, MALLOC, BOOLCONSTANT, NULL, GETBYTE, SETBYTE;

terminal Object     Semicolon, LeftParenthesis, RightParenthesis, LeftBracket, RightBracket, Comma,
                    /*Arithmetic_Op,*/ Equal, Comparison_op, LeftBrace, RightBrace, Point, Logical_Op;

terminal Object     plus,Negation,mult,div,mod;

terminal Object     EXCLA, Less, Greater;

terminal String     ident, STRINGCONSTANT;
terminal String     INTCONSTANT;
terminal String     DOUBLECONSTANT;

non terminal Object Program, Decl, VariableDecl, Variable, Type, FunctionDecl, Formals, ClassDecl, Field, 
                    InterfaceDecl, Prototype, StmtBlock, Stmt, IfStmt, WhileStmt, ForStmt, ReturnStmt, 
                    BreakStmt, PrintStmt, Expr, LValue, Call, LibCall, Actuals, Constant;

non terminal Object ProgramA, FormalsA, ClassDeclC, ClassDeclBb, ClassDeclB, ClassDeclA, InterfaceDeclA, IfStmtA,
                    PrintStmtA, PrintStmtAa, ForStmtA, ActualsA, StmtBlockA, StmtBlockB;


   
precedence left     INT, DOUBLE, BOOL, STRING, VOID, CLASS, EXTENDS, IMPLEMENTS, INTERFACE, IF,
                    ELSE, WHILE, FOR, RETURN, BREAK, PRINT, THIS, NEW, NEWARRAY, READINTEGER,
                    READLINE, MALLOC, BOOLCONSTANT, NULL, GETBYTE, SETBYTE;
precedence left     Semicolon;

precedence left     LeftParenthesis, RightParenthesis, LeftBracket, RightBracket, Comma,
                    /*Arithmetic_Op,*/ Equal,Comparison_op, LeftBrace, RightBrace, Point, Logical_Op;
 
precedence left     STRINGCONSTANT, INTCONSTANT, DOUBLECONSTANT, ident, EXCLA, Negation, Less, Greater;

precedence left     plus,Negation;
precedence left     mult,div,mod;
                    
Program             ::= Decl ProgramA {: :};
ProgramA            ::= Decl ProgramA
                      |;

Decl                ::= VariableDecl
                      | FunctionDecl
                      | ClassDecl
                      | InterfaceDecl
                      | error Semicolon
                      | error RightBracket;

VariableDecl        ::= Variable:v Semicolon {:RESULT = v;:};
Variable            ::= Type:t ident:i {: RESULT = t;:};
Type                ::= INT     {: RESULT ="int";:}
                      | DOUBLE  {: RESULT ="double";:}
                      | BOOL    {: RESULT ="bool";:}
                      | STRING  {: RESULT ="string";:}
                      | ident:i {: RESULT = i;:}
                      | Type:t LeftBracket RightBracket{: RESULT = t;:}; 
FunctionDecl        ::= Type:t ident:i LeftParenthesis Formals RightParenthesis StmtBlock
                      | VOID:t ident:i LeftParenthesis Formals RightParenthesis StmtBlock;

Formals             ::= Variable:v FormalsA
                      |;
FormalsA            ::= Comma Variable:v FormalsA
                      |;

ClassDecl           ::= CLASS ident ClassDeclA ClassDeclB LeftBracket ClassDeclC RightBracket;
ClassDeclA          ::= EXTENDS ident |;
ClassDeclB          ::= IMPLEMENTS ident ClassDeclBb |;
ClassDeclBb         ::= Comma ident ClassDeclBb |;
ClassDeclC          ::= Field ClassDeclC |;

Field               ::= VariableDecl 
                      | FunctionDecl;

InterfaceDecl       ::= INTERFACE ident LeftBracket InterfaceDeclA RightBracket;
InterfaceDeclA      ::= Prototype InterfaceDeclA |;

Prototype           ::= Type ident LeftParenthesis Formals RightParenthesis Semicolon
                      | VOID ident LeftParenthesis Formals RightParenthesis Semicolon;

StmtBlock           ::= LeftBracket StmtBlockA StmtBlockB RightBracket;
StmtBlockA          ::= StmtBlockA  VariableDecl|;
StmtBlockB          ::= Stmt StmtBlockB|;

Stmt                ::= Expr Semicolon
                      | Semicolon
                      | IfStmt
                      | WhileStmt
                      | ForStmt
                      | BreakStmt
                      | ReturnStmt
                      | PrintStmt
                      | StmtBlock;
IfStmt              ::= IF LeftParenthesis Expr RightParenthesis Stmt IfStmtA;
IfStmtA             ::= ELSE Stmt | ;

WhileStmt           ::= WHILE LeftParenthesis Expr RightParenthesis Stmt;

ForStmt             ::= FOR LeftParenthesis ForStmtA Semicolon Expr Semicolon ForStmtA RightParenthesis;
ForStmtA            ::= Expr |;
ReturnStmt          ::= RETURN ForStmtA Semicolon;

BreakStmt           ::= BREAK Semicolon;

PrintStmt           ::= PRINT LeftParenthesis PrintStmtA RightParenthesis Semicolon;
PrintStmtA          ::= Expr PrintStmtAa;
PrintStmtAa         ::= Comma Expr PrintStmtAa | ;

Expr                ::= LValue:i Equal Expr:e 
                      | Constant:c {:RESULT = c;:}
                      | Negation Expr
                      | EXCLA Expr
                      /*| Expr Negation Expr*/
                      | Expr Less Expr
                      | Expr Greater Expr
                      | LValue
                      | THIS
                      | Call
                      | LeftParenthesis Expr RightParenthesis 
                      | Expr:e1 plus Expr:e2    {:if((type(e1) == "str") && (type(e2) == "str")){
                                                RESULT = e1.toString() + e2.toString();
                                                }else if ((type(e1) == "int") && (type(e2) == "int")) {
                                                RESULT = ((Integer)e1) + ((Integer)e2);
                                                }else if (((type(e1) == "int")||(type(e1) == "doub")) && ((type(e2) == "int")||(type(e2) == "doub"))) {
                                                RESULT = ((Double)e1) + ((Double)e2);
                                                }else{
                                                RESULT = null;
                                                if ((type(e1) != "n") && (type(e2) != "n")){
                                                System.out.println("ERROR wrong types" + e1 + " " + e2);
                                                }
                                                }:}
                      | Expr:e1 Negation Expr:e2 {:if ((type(e1) == "int") && (type(e2) == "int")) {
                                                RESULT = ((Integer)e1) - ((Integer)e2);
                                                }else if (((type(e1) == "int")||(type(e1) == "doub")) && ((type(e2) == "int")||(type(e2) == "doub"))) {
                                                RESULT = ((Double)e1) - ((Double)e2);
                                                }else{
                                                RESULT = null;
                                                if ((type(e1) != "n") && (type(e2) != "n")){
                                                System.out.println("ERROR wrong types"+ e1 + " " + e2);
                                                }
                                                }:}
                      | Expr:e1 mult Expr:e2    {:if ((type(e1) == "int") && (type(e2) == "int")) {
                                                RESULT = ((Integer)e1) * ((Integer)e2);
                                                }else if (((type(e1) == "int")||(type(e1) == "doub")) && ((type(e2) == "int")||(type(e2) == "doub"))) {
                                                RESULT = ((Double)e1) * ((Double)e2);
                                                }else{
                                                RESULT = null;
                                                if ((type(e1) != "n") && (type(e2) != "n")){
                                                System.out.println("ERROR wrong types"+ e1 + " " + e2);
                                                }
                                                }:}
                      | Expr:e1 div Expr:e2     {:if ((type(e1) == "int") && (type(e2) == "int")) {
                                                RESULT = ((Integer)e1) / ((Integer)e2);
                                                }else if (((type(e1) == "int")||(type(e1) == "doub")) && ((type(e2) == "int")||(type(e2) == "doub"))) {
                                                RESULT = ((Double)e1) / ((Double)e2);
                                                }else{
                                                RESULT = null;
                                                if ((type(e1) != "n") && (type(e2) != "n")){
                                                System.out.println("ERROR wrong types"+ e1 + " " + e2);
                                                }
                                                }:}
                      | Expr:e1 mod Expr:e2 }   {:if ((type(e1) == "int") && (type(e2) == "int")) {
                                                RESULT = ((Integer)e1) % ((Integer)e2);
                                                }else if (((type(e1) == "int")||(type(e1) == "doub")) && ((type(e2) == "int")||(type(e2) == "doub"))) {
                                                RESULT = ((Double)e1) % ((Double)e2);
                                                }else{
                                                RESULT = null;
                                                if ((type(e1) != "n") && (type(e2) != "n")){
                                                System.out.println("ERROR wrong types"+ e1 + " " + e2);
                                                }
                                                }:}
                      | Expr Comparison_op Expr
                      | Expr Logical_Op Expr
                      | NEW LeftParenthesis ident:i RightParenthesis
                      | NEWARRAY LeftParenthesis Expr Comma Type RightParenthesis
                      | READINTEGER LeftParenthesis RightParenthesis
                      | READLINE LeftParenthesis RightParenthesis
                      | MALLOC LeftParenthesis Expr RightParenthesis;

LValue              ::= ident:i     {:RESULT = i;:}
                      | Expr Point ident:i    
                      | Expr LeftBrace Expr RightBrace;

Call                ::= ident LeftParenthesis Actuals RightParenthesis
                      | Expr Point ident LeftParenthesis Actuals RightParenthesis
                      | Expr Point LibCall LeftParenthesis Actuals RightParenthesis;

LibCall             ::= GETBYTE LeftParenthesis Expr RightParenthesis
                      | SETBYTE LeftParenthesis Expr Comma Expr RightParenthesis;

Actuals             ::= Expr ActualsA
                      | ;
ActualsA            ::= Comma Expr ActualsA 
                      | ;

Constant            ::= INTCONSTANT:v       {:RESULT = v;:}
                      | DOUBLECONSTANT:v    {:RESULT = v;:}
                      | BOOLCONSTANT:v      {:RESULT = v;:}
                      | STRINGCONSTANT:v    {:System.out.println(" \\ 0.0/ "+v);RESULT = v;:}
                      | NULL;